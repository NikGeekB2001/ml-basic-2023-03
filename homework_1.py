Skip to content
 
Search…
All gists
Back to GitHub
@NikGeekB2001 
@NikGeekB2001
NikGeekB2001/homework_1.py
Last active 1 hour ago
0
Code
Revisions
2
<script src="https://gist.github.com/NikGeekB2001/bb0789f9078993b9faebf3c70aafcd38.js"></script>
Описание
homework_1.py
# Задача 1
# N хоббитов делят K кусков эльфийского хлеба поровну,
# # не делящийся нацело остаток остается в корзинке у Сэма.
# # Напишите функцию, которая принимает на вход параметры N и K и возвращает два числа:
# # x - cколько кусков эльфиского хлеба достанется каждому хоббиту,
# # и y - сколько кусков остаётся в корзинке.
# # def share_bread(N, K):
# your code here return x, y # если в функции всё верно, то после выполнения этой строчки,
# не должно выскакивать ошибок assert share_bread(N=3, K=14) == (4, 2)

# Ответ на задачу 1
#  В задаче нужно разделить количество кусков эльфийского хлеба (K)
# на число хоббитов (N) и найти количество кусков эльфийского хлеба, которые достанутся каждому хоббиту
# (K // N, оператор деления нацело //) на число хоббитов.
# А теперь рaссчитаем  количество кусков (14 -(12) = 2) эльфийского хлеба оставшихся в корзинке -
# (K % N, оператор % возвращает остаток от деления).

def share_bread(N, K):
    x = K // N  # количество кусков, которые достанутся каждому хоббиту
    y = K % N  # количество кусков, которые останутся в корзинке у Сэма
    return x, y


assert share_bread(N=3, K=14) == (4, 2)

print(share_bread(N=3, K=14))

print('Задача 1 ------------------------------------------------------------------------->')


# Задача 2
# В копях Мории хоббиты нашли стену, на которой высечены разные натуральные числа.
# Согласно древним сказаниям, это даты сражений.
# Хоббиты знают, что сражения происходили только по високосным годам.
# Помогите хоббитам определить, является ли год с данным числом датой великого сражения.
# Если это так, то верните строку "YOU SHALL PASS", иначе верните "YOU SHALL NOT PASS".
# Напомним, что в соответствии с хоббитским календарем, год является високосным,
# если его номер кратен 4, но не кратен 100, а также если он кратен 400.

# def leap_year(year):
#     # your code here
#     return text_result
#
# assert leap_year(5) == 'YOU SHALL NOT PASS'

# В функции leap_year нужно проверить, является ли год year високосным, и вернуть соответствующую строку.
# Вот решение:
def leap_year(year):
    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):
        return "YOU SHALL PASS"
    else:
        return "YOU SHALL NOT PASS"

# Ниже преведено пояснение алгоритма проверки на високосность года:
#  а) год високосный, если он кратен 4 и не кратен 100
#  б) год високосный, если он кратен 400.
# п. 1 Нужно проверить условие year % 4 == 0, чтобы определить, является ли год кратным 4.
# п. 2 Затем неоюходимо проверить условие (year % 100 != 0 or year % 400 == 0).
# В этой функции мы используем операторы % (остаток от деления) и != (не равно).
# Оператор % возвращает остаток от деления левого операнда на правый.
# Если год делится на 4 без остатка и при этом не делится на 100 без остатка,
# то он является високосным (первое условие). Если год делится на 400 без остатка,
# то он также является високосным (второе условие).
# Если это условие истинно, то год високосный и функция возвращает строку "YOU SHALL PASS".
# В противном случае функция возвращает строку "YOU SHALL NOT PASS".
# Тест на год = 5 _ assert leap_year(5) == 'YOU SHALL NOT PASS' проходит успешно,
# так как год 5 не является високосным.

print(leap_year(10))
print(leap_year(2024))

assert leap_year(10) == 'YOU SHALL NOT PASS'
assert leap_year(2024) == 'YOU SHALL PASS'

print('Задача 2 ------------------------------------------------------------------------->')

# Задача 3
# Для могущественного магического ритуала Гендальфу необходимо быстро подсчитывать площадь своего амулета,
# который умеет менять размеры. Известно, что амулет имеет форму треугольника и Гендальф знает длину каждой из сторон.
# Напишите функцию, которая считает площадь амулета по трем сторонам.
# Подсказка: используйте формулу Герона S=√p(p−a)(p−b)(p−c) S=p(p−a)(p−b)(p−c)p=a+b+c2p=a+b+c2
# def amulet_area(a, b, c):
#     # your code here
#     return S
#
# assert amulet_area(3, 4, 5) == 6

# Решение вашей задачи:

# Формула S = √p(p - a)(p - b)(p - c) является формулой Герона для вычисления площади любого треугольника.
# Обычно эта формула применяется для вычисления площади треугольника, зная длины его всех сторон.
# А вот p в данной формуле является полу периметром треугольника.
# А вычислить его мы можем по следующей формуле:
# p = (a + b + c)/2.
# Полу периметр треугольника равен сумме длин сторон треугольника деленной на два.
# Давайте найдем полу периметр для треугольника со сторонами a = 2; b = 3; c = 5.
# p = (a + b + c)/2 = (2 + 3 + 5)/2 = 10/2 = 5.
# Формула S = √p(p - a)(p - b)(p - c) является формулой Герона для вычисления площади любого треугольника.
# Обычно эта формула применяется для вычисления площади треугольника, зная длины его всех сторон.
# А вот p в данной формуле является полу периметром треугольника.
# А вычислить его мы можем по следующей формуле:
# p = (a + b + c)/2.
# Полу периметр треугольника равен сумме длин сторон треугольника деленной на два.
# Давайте найдем полу периметр для треугольника со сторонами a = 2; b = 3; c = 5.
# p = (a + b + c)/2 = (2 + 3 + 5)/2 = 10/2 = 5.
# _________________________________________________________
# Площадь треугольника можно вычислить по формуле S=√p(p-a)(p-b)(p-c), где а, b, с – стороны треугольника,
# а p=(a+b+c)/2 - полупериметр треугольника.
# Площадь треугольника можно вычислить по формуле S=√p(p-a)(p-b)(p-c), где а, b, с – стороны треугольника,
# а p=(a+b+c)/2 - полупериметр треугольника.

import math

def amulet_area(a, b, c):
    p = (a + b + c) / 2
    S = math.sqrt(p * (p - a) * (p - b) * (p - c))
    return S

# В этом решении мы сначала находим полупериметр p (половину суммы длин сторон),
# а затем используем формулу Герона, чтобы вычислить площадь S.
# Здесь мы импортируем модуль math для использования функции sqrt, которая вычисляет квадратный корень.
# Вы можете проверить решение, используя утверждение assert, которое проверяет,
# что функция amulet_area(3, 4, 5) возвращает ожидаемый результат 6.

assert amulet_area(3, 4, 5) == 6

print(amulet_area(3, 4, 5))

print('Задача 3 ------------------------------------------------------------------------->')

# Задача 4
# Хоббиты собираются пешком идти до Мордора и им нужно подсчитать расстояние,
# которое им предстоит пройти. Хоббиты смогли вспомнить сразу несколько метрик расстояния:
# евклидово, манхэттена и косинусное, так что ваша задача - напистаь функцию под каждую из них.
# Важное условие - используйте только базовые функции numpy для решения.
# •	Евклидово расстояниеd(a,b)=√∑i(ai−bi)2d(a,b)=∑i(ai−bi)2
# •	Расстояние Манхэттенаd(a,b)=∑i|ai−bi|d(a,b)=∑i|ai−bi|
# •	Косинусное расстояниеd(a,b)=1−a⊤b||a||2⋅||b||2d(a,b)=1−a⊤b||a||2⋅||b||2
# def cal_euclidean(a, b):
#     ## Your code here
#     return distance
#
# def cal_manhattan(a, b):
#     ## Your code here
#     return distance
#
# def cal_cosine(a, b):
#     ## Your code here
#     return distance
# a = np.random.randint(-10, 10, size=10)
# b = np.random.randint(-10, 10, size=10)
# print(cal_euclidean(a, b))
# print(cal_manhattan(a, b))
# print(cal_cosine(a, b))

# Вот решение для каждой из метрик:

import numpy as np
# Для решения использованы функции np.sqrt, np.sum, np.abs, np.dot, np.linalg.norm,
# которые все входят в библиотеку numpy.

# Решение
# •	Евклидово расстояниеd(a,b)=√∑i(ai−bi)2d(a,b)=∑i(ai−bi)2
# Функция cal_euclidean вычисляет евклидово расстояние между векторами a и b.
# Сначала вычитаем один вектор из другого (a - b), затем возводим разности
# в квадрат и складываем их с помощью np.sum. И наконец, мы извлекаем квадратный корень из этой суммы,
# чтобы получить итоговое расстояние.
def cal_euclidean(a, b):
    distance = np.sqrt(np.sum((a - b) ** 2))
    # можно с функцией np.square # distance = np.sqrt(np.sum(np.square(a-b)))
    return distance

# •	Расстояние Манхэттенаd(a,b)=∑i|ai−bi|d(a,b)=∑i|ai−bi|
#  Функция cal_manhattan вычисляет расстояние Манхэттена между векторами a и b.
# Мы снова вычитаем один вектор из другого (a - b), но на этот раз мы берем абсолютное значение разностей,
# используя np.abs, а затем складываем все значения с помощью np.sum.
def cal_manhattan(a, b):
    distance = np.sum(np.abs(a - b))
    return distance

# •	Косинусное расстояниеd(a,b)=1−a⊤b||a||2⋅||b||2d(a,b)=1−a⊤b||a||2⋅||b||2
# Функция cal_cosine вычисляет косинусное расстояние между векторами a и b.
# Мы сначала вычисляем скалярное произведение векторов a и b, используя np.dot.
# Затем мы делим это скалярное произведение на произведение длин векторов a и b,
# используя np.linalg.norm, и вычитаем это значение из 1.
def cal_cosine(a, b):
    distance = 1 - np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))
    return distance

# Затем мы генерируем два случайных вектора a и b с помощью np.random.randint()
# и вычисляем расстояние для каждой метрики с помощью соответствующей функции.
a = np.random.randint(-10, 10, size=10)
b = np.random.randint(-10, 10, size=10)

# Функции возвращают результаты расстояний, которые мы логируем на экран.
print(cal_euclidean(a, b))
print(cal_manhattan(a, b))
print(cal_cosine(a, b))

# На выходе мы получим значение каждого расстояния для двух случайных векторов:
print("Вектор A: ", a)
print("Вектор B: ", b)

print('Задача 4 ------------------------------------------------------------------------->')

import numpy as np

def cal_euclidean(a, b):
    return np.sqrt(np.sum(np.square((a - b))))

def cal_manhattan(a, b):
    return np.sum(np.abs(a - b))

def cal_cosine(a, b):
    return 1 - np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))


def cal_cosine(a, b):
    dot_product = np.dot(a, b)
    norm_a = np.sqrt(np.sum(np.square(a)))
    norm_b = np.sqrt(np.sum(np.square(b)))
    distance = 1 - dot_product / (norm_a * norm_b)
    return distance

a = np.random.randint(-10, 10, size=10)
b = np.random.randint(-10, 10, size=10)

print("a: ", a)
print("b: ", b)

print("Euclidean distance: ", cal_euclidean(a, b))
print("Manhattan distance: ", cal_manhattan(a, b))
print("Cosine distance: ", cal_cosine(a, b))

print('Задача 5 ------------------------------------------------------------------------->')

# Задача 5
# Ну и напоследок, еще немного практики numpy, без которой не обходится ни один хоббит.
# Создайте случайный array (np.random.rand()) длинной 100. Преобразуйте его так, чтобы
# •	Максимальный элемент(ы) был равен 1
# •	Минимальный элемент(ы) был равен 0
# •	Остальные элементы в итнтервале от 0 до 1 остаются прежними
# my_array = ## Your code here
# print(np.max(my_array), np.min(my_array))
# print(my_array)
# Создайте array размером 5×65×6 с целыми числами в интервале [0,50].
# Напечатайте колонку, которая содержит максимальный элемент полученной матрицы
# my_array = ## Your code here
# selected_column = ## Your code here
# print('Shape: ',my_array.shape)
# print('Array')
# print(my_array)
# print(selected_column)

# Напишите функцию, которая принимает на вохд матрицу (array) X и возвращает
# все её уникальные строки в виде новой матрицы.
# def get_unique_rows(X):
#     # Your code here
#     return X_unique
# X = np.random.randint(4, 6, size=(10,3))
# print(X)
# get_unique_rows(X)

# Ответ на задачу
# 1.  Можно использовать функции `np.argmax()` и
# `np.argmin()` для получения индексов максимального и минимального элементов массива:

import numpy as np

my_array = np.random.rand(100)
max_index = np.argmax(my_array)
# Функция `np.argmax()` в библиотеке NumPy возвращает индекс элемента массива
# с максимальным значением. Если на вход функции подается многомерный массив,
# то функция возвращает индекс элемента с максимальным значением в плоском (прямом) массиве,
# т.е. соответствующий индексам элемента в изначальном многомерном массиве.
# Например, если мы имеем массив `[3, 2, 7, 1, 9]`, то функция `np.argmax()` вернет значение `4`,
# что соответствует индексу элемента 9. Если же мы имеем двумерный массив `[[2, 5, 7], [1, 6, 3], [9, 0, 4]]`,
# то функция вернет значение `6`, соответствующее индексу элемента 9 в плоском массиве `[2, 5, 7, 1, 6, 3, 9, 0, 4]`.
#
min_index = np.argmin(my_array)
# # Функция np.argmin() из библиотеки NumPy возвращает индекс минимального элемента массива.
# # Например, для массива arr = [3, 7, 1, 5, 2] вызов функции np.argmin(arr) вернет 2,
# # так как минимальный элемент массива равен 1 и его индекс равен 2.
# # Если в массиве есть несколько элементов с одинаковым минимальным значением,
# # то будет возвращен индекс первого из них.
# # Также можно использовать функцию np.argmin() для поиска минимального элемента в
# # определенной оси массива, указав номер этой оси вторым параметром.
#
my_array[max_index] = 1
my_array[min_index] = 0

print(np.max(my_array), np.min(my_array))
print('Cлучайный array')
print(my_array)

# 2. Создание array размером 5×65×6 с целыми числами в интервале [0,50]. Нахождение колонки,
# содержащей максимальный элемент:
# Создаем массив размером 5x65x6 с числами в интервале [0, 50]
my_array = np.random.randint(0, 51, size=(5, 65, 6))

# Находим индекс колонки с максимальным элементом
max_index = np.unravel_index(my_array.argmax(), my_array.shape)[1]

# Данный код используется для получения индексов максимального элемента массива.
# `my_array.argmax()` - возвращает индекс максимального элемента в массиве `my_array`.
# `np.unravel_index` - используется для конвертации одномерного индекса
# в индексы соответствующих многомерных координат.
# Таким образом, `np.unravel_index(my_array.argmax(), my_array.shape)`
# вернет индексы максимального элемента в массиве `my_array`..

# Код `my_array.shape` возвращает кортеж, содержащий размеры массива
# (например, для двумерного массива (строк, столбцов)).
# При этом `[1]` обращается к второму элементу кортежа (индексация в Python начинается с 0).
# Таким образом, `my_array.shape[1]` возвращает количество столбцов в двумерном массиве `my_array`.

# Выбираем эту колонку и логируем
selected_column = my_array[:, max_index, :]

# Код `selected_column = my_array[:, max_index, :]` используется для выбора всех элементов
# из трехмерного массива `my_array` по определенному индексу `max_index`.
# Это делается с помощью специальных индексов в квадратных скобках (`[]`).
# В данном случае мы используем двоеточие (`:`), чтобы выбрать все элементы первого (нулевого),
# и третьего (второго) измерения массива `my_array`. А второе измерение (одномерный массив)
# выбирается по индексу `max_index`.
# Таким образом, код `selected_column = my_array[:, max_index, :]` создает новый массив `selected_column`,
# содержащий все элементы из `my_array`, которые имеют индекс `max_index` во второй размерности.

print('Shape: ', my_array.shape)
print('Array:')
print(my_array)
print('Selected column:')
print(selected_column)

print('Создание array размером 5×65×6 с целыми числами в интервале ------------------------------------')

def get_unique_rows(X):
    X_unique = np.unique(X, axis=0)
    return X_unique

X = np.random.randint(4, 6, size=(10,3))
print(X)

X_unique = get_unique_rows(X)
print("Уникальные строки:")
print(X_unique)
get_unique_rows(X)

print('Функция, которая принимает на вход матрицу (array) X и возвращает все уникальные строки в виде новой матрицы>')
# Функция `np.unique` возвращает уникальные элементы в массиве.
# Так как мы хотим получить уникальные строки матрицы `X`, мы указываем параметр `axis=0`,
# который говорит функции сравнивать строки.
# Результатом работы функции будет матрица `X_unique`,
# которая содержит все уникальные строки матрицы `X`.
# np.unique` обрабатывает матрицу таким образом, что остаются только уникальные строки
# (параметр `axis=0` указывает на то, что обрабатывать нужно построчно).
# Результат функции - это новая матрица, состоящая из уникальных строк.
@NikGeekB2001
 
Add heading textAdd bold text, <Ctrl+b>Add italic text, <Ctrl+i>
Add a quote, <Ctrl+Shift+.>Add code, <Ctrl+e>Add a link, <Ctrl+k>
Add a bulleted list, <Ctrl+Shift+8>Add a numbered list, <Ctrl+Shift+7>Add a task list, <Ctrl+Shift+l>
Directly mention a user or team
Reference an issue or pull request
Leave a comment
Файл не выбран
Attach files by dragging & dropping, selecting or pasting them.
Styling with Markdown is supported
Footer
© 2023 GitHub, Inc.
Footer navigation
Terms
Privacy
Security
Status
Docs
Contact GitHub
Pricing
API
Training
Blog
About
Описание
