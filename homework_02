Python Домашнее задание
Пишем классы и плодим наследников
Цель:
В этом ДЗ вы напишите базовый класс и сделаете наследников, которые будут реализовывать различные методы.

Описание/Пошаговая инструкция выполнения домашнего задания:
скопируйте папку homework_02 для этой домашки
1. В модуле exceptions объявите следующие исключения:
LowFuelError
NotEnoughFuel
CargoOverload
2. Доработайте базовый класс base.Vehicle:
добавьте атрибуты weight, started, fuel, fuel_consumption со значениями по умолчанию
добавьте инициализатор для установки weight, fuel, fuel_consumption
добавьте метод start, который, если ещё не состояние started, проверяет, что топлива больше нуля,
и обновляет состояние started, иначе выкидывает исключение exceptions.LowFuelError
добавьте метод move, который проверяет, что достаточно топлива для преодоления переданной дистанции,
и изменяет количество оставшегося топлива, иначе выкидывает исключение exceptions.NotEnoughFuel

3. Создайте датакласс Engine в модуле engine, добавьте атрибуты volume и pistons
в модуле car создайте класс Car
класс Car должен быть наследником Vehicle
добавьте атрибут engine классу Car
объявите метод set_engine, который принимает в себя экземпляр объекта Engine и устанавливает на текущий экземпляр Car
4. В модуле plane создайте класс Plane
класс Plane должен быть наследником Vehicle
добавьте атрибуты cargo и max_cargo классу Plane
добавьте max_cargo в инициализатор (переопределите родительский)
5. Объявите метод load_cargo, который принимает число, проверяет, что в сумме с текущим cargo не будет перегруза, 
и обновляет значение, в ином случае выкидывает исключение exceptions.CargoOverload
6. Объявите метод remove_all_cargo, который обнуляет значение cargo и возвращает значение cargo, 
которое было до обнуления.




 <h4 style= 'color: red'> Для выполнения данного задания нужно создать три модуля: </h4>
 
#### base.py, car.py, plane.py, а также модуль exceptions
#### В модуле exceptions.py объявим три исключения:
#### Пользовательские исключения - это специальные классы, которые вы можете создать для обработки ошибок в вашей программе. Они наследуются от встроенного класса Exception или одного из его подклассов. 
 <h4 style= 'color: red'> Для объявления исключений нужно создать новый класс, который наследуется от встроенного класса Exception или одного из его подклассов </h4>

# Создаем классы для ошибок, которые могут возникнуть при работе с транспортными средствами
class LowFuelError(Exception):
    # Эта ошибка возникает, когда топлива осталось мало
    pass

class NotEnoughFuel(Exception):
    # Эта ошибка возникает, когда топлива не хватает для совершения поездки
    pass

class CargoOverload(Exception):
    # Эта ошибка возникает, когда груз превышает допустимый вес для транспортного средства
    pass



 <h4 style= 'color: red'> Доработаем базовый класс Vehicle: добавим атрибуты weight, started, fuel, fuel_consumption со значениями по умолчанию </h4>

#### Добавим метод start, который, если ещё не состояние started, проверяет, что топлива больше нуля, и обновляет состояние started, иначе выкидывает исключение exceptions.LowFuelError. Добавим метод move, который проверяет, что достаточно топлива для преодоления переданной дистанции, и изменяет количество оставшегося топлива, иначе выкидывает исключение exceptions.NotEnoughFuel

# Метод называется ициализатором. 
# Он вызывается при создании нового объекта класса Vehicle. 
# И принимает три параметра: weight, fuel и fuel_consumption, которые имеют значения по умолчанию 0. 
# Эти параметры используются для установки атрибутов объекта с такими же именами. 
# Атрибуты - это переменные, которые хранят информацию о состоянии объекта. 
# Например, атрибут weight хранит вес транспортного средства, атрибут fuel хранит количество топлива,
# а атрибут fuel_consumption хранит расход топлива на единицу расстояния. 
# Инициализатор также устанавливает атрибут started в False, что означает, что транспортное средство еще не запущено.

class Vehicle:
    def __init__(self, weight=0, fuel=0, fuel_consumption=0):
        # инициализация транспортного средства с заданными весом, топливом и расходом топлива
        # init это специальный метод в Python, который вызывается при создании нового объекта класса.
        # Он используется для инициализации атрибутов объекта с заданными значениями.
        # Например, в классе Person мы используем init для установки имени и возраста для каждого объекта
        # этого класса. init не является конструктором, так как он не создает объект, а только 
        # инициализирует его атрибуты. 
        # init имеет два подчеркивания с каждой стороны, что означает, что он является внутренним методом Python
        # и не должен вызываться явно.
        self.weight = weight # масса (вес)
        self.fuel = fuel  # топливо
        self.fuel_consumption = fuel_consumption   # расход топлива
        self.started = False    # состояние двигателя (заведен или нет)
# Self - это специальный параметр, который используется в методах класса. 
# Он ссылается на текущий объект класса, для которого вызывается метод. Он нужен для доступа к атрибутам 
# и другим методам объекта. Например, в методе start мы используем self.started для проверки и обновления 
# состояния запуска транспортного средства

    def start(self):
        # метод для запуска транспортного средства
        if not self.started: # если транспортное средство еще не запущено
            if self.fuel > 0: # если есть топливо в баке (больше ноля)
                self.started = True # то говорим "да" и  обновляем состояние на запущено
            else: # если нет топлива
                raise LowFuelError("Не хватает топлива для запуска") # raise это ключевое слово в Python, 
                # которое используется для возбуждения исключений или ошибок. 
                # Когда мы используете raise, мы указываем, какой тип исключения хотим вызвать. 
        else: 
            print("Транспортное средство уже запущено") # вывести сообщение

    def move(self, distance):
        # метод, который проверяет, что достаточно топлива для преодоления переданной дистанции
        calculating_fuel = distance * self.fuel_consumption # вычислить необходимое количество топлива
         # Distance - означает расстояние между двумя точками или объектами. 
         # В нашем коде distance - это аргумент функции move, 
         # который задает, на сколько километров мы хотим переместить транспортное средство.
         # Например, если мы хотим проехать 10 километров, мы вызываем функцию move с аргументом 10.
         # Функция move проверяет, хватит ли топлива для этого расстояния, и если да,
         # то уменьшает количество топлива на величину, равную расстоянию умноженному на расход топлива.
         # Если нет, то выбрасывает ошибку "Не хватает топлива для движения".
        
        if calculating_fuel <= self.fuel: # если топлива хватает
            self.fuel = self.fuel - calculating_fuel # уменьшаем количество оставшегося топлива
            print(f"Транспортное средство проехало {distance} км") # выводим сообщение
        else: # если топлива не хватает
            raise NotEnoughFuel("Не хватает топлива для движения") # выбрасываем ошибку

 <h4 style= 'color: red'> Создаем датакласс Engine в модуле engine, добавьте атрибуты volume и pistons </h4>

# Создаем датакласс Engine в модуле engine, добавляем атрибуты volume и pistons

# Импорт модуля dataclasses
from dataclasses import dataclass

# Создаем датакласс Engine с атрибутами volume и pistons
@dataclass
class Engine:
    volume: int
    pistons: int
# Датаклассы в Python - это специальные классы, которые автоматически генерируют некоторые методы 
# для работы с данными, такие как init, repr, eq и другие. 
# Для создания датакласса нужно использовать декоратор @dataclass,
# который импортируется из модуля dataclasses.
# Декоратор - это функция, которая принимает другую функцию или класс и изменяет её поведение. 
# В данном случае декоратор @dataclass принимает класс Engine и делает его датаклассом.

# Атрибуты датакласса объявляются как переменные класса с указанием их типов. 
# В данном случае атрибуты volume и pistons имеют тип int, то есть целое число. 

<h4 style= 'color: red'>  Создадим класс Car, он должен быть наследником Vehicle, добавляем атрибут engine классу Car 
и объявляем метод set_engine, который принимает в себя экземпляр объекта Engine и устанавливает на текущий экземпляр Car </h4>



# В этом модуле мы создаете класс Car, который представляет автомобиль. Этот класс наследуется от класса Vehicle,
# который определен в модуле base. Это означает, что класс Car наследует все атрибуты и методы класса Vehicle,
# такие как weight, started, fuel, fuel_consumption.
# Однако класс Car имеет дополнительный атрибут engine, который представляет двигатель автомобиля.
# Этот атрибут имеет значение по умолчанию None, что означает, что по умолчанию автомобиль не имеет двигателя
#(потом мы его установим).
# Чтобы установить двигатель на автомобиль, мы определяеем метод set_engine, который принимает в себя экземпляр объекта Engine
# и устанавливает его на текущий экземпляр Car. Объект Engine определен в модуле engine и имеет атрибуты volume и pistons.
# Например, вы можете создать объект Car с весом 2000 кг (2 t), топливом 100 литров и расходом топлива 8,7 литра на километр:

class Car(Vehicle):
    def __init__(self, weight=0, fuel=0, fuel_consumption=0):
        super().__init__(weight, fuel, fuel_consumption)
        self.engine = None

    def set_engine(self, engine: Engine):
        self.engine = engine
        print(f"Установлен двигатель объемом {engine.volume} л и {engine.pistons} цилиндрами")

<h4 style= 'color: blue'> 
    ... car1 = Car(1500, 50, 0.1) ... 
    
По умолчанию этот объект не имеет двигателя
    
...print(car1.engine) # None...
    
Устанавливаем этот двигатель на автомобиль с помощью метода set_engine:
    
...car1.set_engine(engine1)...
    
Теперь этот объект имеет двигатель:
    
...print(car1.engine) # Engine(volume=2, pistons=4)...
    
Мы можем использовать методы start и move для запуска и перемещения автомобиля:
...car1.start() # запуск автомобиля...
    
...car1.move(100) # перемещение на 100 километров...
    
... print(car1.fuel) # остаток топлива: 40 литров...
</h4>

<h4 style= 'color: red'> В модуле plane создайте класс Plane класс Plane должен быть наследником Vehicle добавьте атрибуты cargo и max_cargo классу Plane добавьте max_cargo в инициализатор (переопределите родительский) </h4>

# Здесь мы определяем класс для самолета, который наследуется от базового класса Vehicle (для транспортных средств) 
# Это означает, что самолет будет иметь все те же атрибуты и методы, что и любое другое транспортное средство.

class Plane(Vehicle):
    # Здесь мы задаем атрибуты по умолчанию для каждого самолета
    # Эти атрибуты будут присвоены каждому экземпляру класса Plane при его создании
     
    def __init__(self, weight=0, fuel=0, fuel_consumption=0, max_cargo=0):
        # Вызываем инициализатор базового класса для установки веса, топлива и расхода топлива
        # Это означает, что мы используем тот же код, что и в классе Vehicle, чтобы не повторяться
        # Мы передаем значения атрибутов weight, fuel и fuel_consumption из текущего экземпляра класса Plane
        # в качестве аргументов для инициализатора базового класса
        super().__init__(weight, fuel, fuel_consumption)
        # super() в Python - это встроенная функция, которая позволяет получить доступ к методам и свойствам 
        # родительского или соседнего класса. 
        # Груз самолета в килограммах (изначально 0)
        # Это специфический атрибут для самолета, который не имеет смысла для других транспортных средств
        # Мы присваиваем ему значение 0 по умолчанию, но можем передать другое значение при создании экземпляра класса Plane
        self.cargo = 0
        # Максимальный допустимый груз самолета в килограммах
        # Это также специфический атрибут для самолета, который ограничивает количество груза,
        # которое можно загрузить на самолет
        self.max_cargo = max_cargo
        # Мы присваиваем ему значение 0 по умолчанию, но можем передать другое значение при создании экземпляра класса Plane
        # Например: создаем экземпляр класса Plane с максимальным грузом 1000 кг
        # plane = Plane(max_cargo=1000)
        # выводим значение атрибута max_cargo для этого экземпляра
        # print(plane.max_cargo) # 1000

<h4 style= 'color: red'> Объявите метод load_cargo, который принимает число, проверяет, что в сумме с текущим cargo не будет перегруза, и обновляет значение, в ином случае выкидывает исключение exceptions.CargoOverload </h4>

 # метод для загрузки груза на самолет
def load_cargo(self, amount):
        # если сумма текущего груза и загружаемого груза не превышает максимальный груз
    if self.cargo + amount <= self.max_cargo:
            # увеличиваем текущий груз на загружаемый груз
            self.cargo += amount
            # выводим сообщение о загрузке груза
            print(f"Груз загружен: {amount} кг")
    else:
            # иначе выкидываем исключение о перегрузе груза
        raise CargoOverload("Груз превышает допустимый вес для транспортного средства")



<h4 style= 'color: red'> Объявите метод remove_all_cargo, который обнуляет значение cargo и возвращает значение cargo, которое было до обнуления.</h4>

 # метод для разгрузки всего груза с самолета
def remove_all_cargo(self):
        # сохраняем текущий груз в переменную cargo
        cargo = self.cargo
        # обнуляем текущий груз 
        self.cargo = 0
        # выводим сообщение о разгрузке груза
        print(f"Груз разгружен: {cargo} кг")
        # возвращаем значение разгруженного груза 
        return cargo

<h2 stype= 'color: green> ...car1 = Car(1500, 50, 0.1)...
#По умолчанию этот объект не имеет двигателя:

print(car1.engine) # None
#Вы можете создать объект Engine с объемом 2 литра и 4 цилиндрами:

engine1 = Engine(2, 4)
#Вы можете установить этот двигатель на автомобиль с помощью метода set_engine:

car1.set_engine(engine1)#
#Теперь этот объект имеет двигатель:

print(car1.engine) # Engine(volume=2, pistons=4)
#Вы можете использовать методы start и move для запуска и перемещения автомобиля:

car1.start() # запуск автомобиля
car1.move(100) # перемещение на 100 километров
            print(car1.fuel) # остаток топлива: 40 литров </h2>
